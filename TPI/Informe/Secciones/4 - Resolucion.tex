\section{Resolución}

Se utilizaron las siguientes bibliotecas de C para poder llevar a cabo la resolución del problema planteado:
\begin{itemize}
    \item Para ambas implementaciones:
    \begin{itemize}
        \item \texttt{<sys/ipc.h>}: biblioteca de \textit{System V} para la comunicación entre procesos.
        \item \texttt{<sys/time.h>}: biblioteca para obtener el tiempo de la \textit{timestamp}.
        \item \texttt{<sys/shm.h>}: biblioteca de \textit{System V} para la memoria compartida.
    \end{itemize}
    \item Para la resolución con semáforos:
    \begin{itemize}
        \item \texttt{<sys/sem.h>}: implementación de \textit{System V} para semáforos.
    \end{itemize}
    \item Para la resolución por colas de mensajes:
    \begin{itemize}
        \item \texttt{<sys/msg.h>}: implementación de \textit{System V} para colas de mensajes.\\
    \end{itemize}
\end{itemize}

En ambos casos se eligió reservar dos segmentos de memoria compartida, uno para cada mitad del \textit{buffer}, con capacidad para almacenar 100 estructuras de datos en total. Esto se logró mediante la función \texttt{shmget()} (contenida en la biblioteca \texttt{<sys/shm.h>}), a la cual se le pasan como argumentos el tamaño del segmento y una clave única (obtenida con la función \texttt{ftok()}) que debe ser la misma para el productor y el consumidor, para así poder compartir los segmentos creados.\\

Además, dado que los requerimientos no establecen que se debe hacer en el caso que el productor quiera escribir un \textit{buffer} que aun no fue consumido, se decidió priorizar la integridad de los datos a detrimento de la velocidad de respuesta, por lo que el productor espera a que el consumidor finalize de leer los datos del \textit{buffer}.\\

\subsection{Realización con semáforos}

Para la implementación con semáforos, se utilizaron las funciones \texttt{semget()}, \texttt{semctl()}, \texttt{semop()} incluidas en la biblioteca apropiada para implementar 3 semáforos distintos:

\begin{itemize}
    \item \textbf{Semáforo del \textit{buffer} 1}: Este semáforo es bloqueado por alguno de los dos procesos al comenzar operaciones sobre el primer \textit{buffer}, y desbloqueado al terminarlas.
    \item \textbf{Semáforo del \textit{buffer} 2}: De manera similar al semaforo anterior, es bloqueado por alguno de los dos procesos al comenzar operaciones sobre el segundo buffer, y desbloqueado al terminarlas.
    \item \textbf{Semáforo de sincronización}: Se encarga de sincronizar los dos programas, de manera que el productor no sobrescriba datos aún no consumidos.
\end{itemize}

Primeramente, se crean los semáforos y espacios de memoria compartida (con \texttt{shmget()} y \texttt{semget()}), utilizando claves únicas obtenidas con la función \texttt{ftok()}. En este caso, tanto la memoria compartida como los semáforos se crean en el programa productor, por lo que si se llama al consumidor previo a este, se va a arrojar en pantalla un error indicando que no se pudieron obtener los recursos.\\

Una vez creados los semáforos, se inicializan dentro del productor mediante \texttt{semctl()}, y una vez que comienza la lectura y escritura de datos, se opera sobre los mismos mediante la función \texttt{semop} (para incrementar la legibilidad del código, las tres instrucciones requeridas para operar un semáforo se sintetizaron en un macro definido en el \textit{header} del programa).\\

Finalmente, al terminar de correr el productor, se llaman a \texttt{shmctl()} y \texttt{semctl()}, para indicar al sistema que destruya los semáforos y las memorias compartidas que se crearon una vez que el ultimo programa haya dejado de utilizarlos (en este caso el consumidor).\\

\subsubsection{Pseudocódigo}

\begin{lstlisting}[language=C]          % No usar tildes en el pseudocódigo y dejar una linea vacía al principio y al final

    Productor:
    INICIO
        Declarar y asignar variables, macros, estructuras y funciones;
        Obtener la clave de las memorias compartidas (en el caso de no obtenerlas imprimir error);
        Llamar al sistema para obtener el ID de las memorias compartidas (en el caso de que no obtenerlas imprimir error);
        Asociar el espacio de memoria compartida con un puntero (si no puede asociar imprimir error);
        Crar socket para el servidor;
        Crear partida y conexion de jugadores;
        Inicializar semaforos;
        Mientras(El servidor este activo){
            Mientras(No se hayan terminado de conectar los jugadores){
                Esperar a que se conecte un jugador;
                Imprimir desde donde se hizo la conexion;
                Si(Es el primer jugador){
                    Solicitar la cantidad de jugadores que van a jugar (si no se ingresa un numero entre 2 y 4 volver a solicitar);
                }
                Si(Se crea un hijo y se esta en el hijo){
                    Solicitar ingresar un nombre (si no ingresa se le asigna un nombre por defecto);
                    Imprimir mensaje de esperando a los demas jugadores;
                    Avisar al padre que el hijo esta listo;
                }
                Sino{
                    Aumentar la varible turno para llevar la cuenta de clientes conectados;
                    Cerrar conexion no utilizada;
                }
            }
        }
        Si(Estoy en el padre){
            Inicializar la mesa sin cartas;
            Esperar a los jugadores;
            Mientras(Queden cartas por repartir){
                Repartir 3 cartas a cada jugador;
                Si(Es la primera mano){
                    Repartir 4 cartas en la mesa;
                }
                Contar cuantas cartas hay repartidas;
                Imprimir el numero de ronda en el servidor;
                Para(Las 3 rondas){
                    Para(Los 4 jugadores){
                        Enviar a todos los jugadores sus cartas;
                        Enviar a los jugadores que toca jugar;
                        Si al jugador que le tocaba jugar levanto se imprime que fue el ultimo en levantar;
                        Enviar jugada a los demas jugadores;
                    }
                }
            }
            Asignar las cartas sobrantes en mesa al ultimo jugador en levantar;
            Enviar a todos los jugadores que finalizo la partida;
        }
        Sino{
            Inicializar cartas levantadas sin cartas;
            Hacer{
                Si(Se recibe 'A' del padre){
                    Contar cartas en la mesa;
                    Si(Quedan cartas sobre la mesa){
                        Enviar cuales son las cartas;
                    }
                    Sino{
                        Enviar que no hay cartas sobre la mesa;
                    }
                    Si(El jugador tiene cartas en la mano){
                        Enviar cuales son las cartas;
                    }
                    Sino{
                        Enviar que no tiene cartas en la mano;
                    }
                    Si(es el turno del jugador){
                        Imprimir que se espera la jugada;
                    }
                    Sino{
                        Imprimir de quien es el turno;
                    }
                }
                Si(Se recibe 'T' del padre){
                    Si(Es el turno del jugador){
                        Contar cartas en la mesa;
                        Si(Quedan cartas sobre la mesa){
                            Enviar cuales son las cartas;
                        }
                        Sino{
                            Enviar que no hay cartas sobre la mesa;
                        }
                        Si(El jugador tiene cartas en la mano){
                            Enviar cuales son las cartas;
                        }
                        Sino{
                            Enviar que no tiene cartas en la mano;
                        }
                        Mientras(La jugada no sea valida){
                            Si(Quedan cartas sobre la mesa){
                                Preguntar si el jugador quiere levantar o descartar;
                            }
                            Sino{
                                Decirle que descarte;
                            }
                            Si(Levanta){
                                Pedir que seleccione una carta de la mano y las correspondientes de la mesa;
                                Si(la suma no da 15){
                                    La jugada no es valida;
                                }
                                Sino{
                                    Enviar la jugada al padre;
                                    Contar cartas en la mesa;
                                    Si(No quedan cartas sobre la mesa){
                                        El jugador hizo escoba;
                                    }
                                    La jugada es valida;
                                }
                            }
                            Si(Descarta){
                                Pedir que seleccione una carta de la mano para descartar;
                                Enviar la jugada al padre;
                                La jugada es valida;
                            }
                        }
                    }
                }
                Si(Se recibe 'L' del padre){
                    Enviar la jugada de levante que hizo el jugador anterior;
                    Si (Hizo escoba){
                        Enviar que hizo escoba;
                    }
                }
                Si(Se recibe 'D' del padre){
                    Enviar la jugada de descarte que hizo el jugador anterior;
                }
            }Mientras(La partida no finalizo)
            Para(Las 4 jugadores){
                Enviar las cartas que levanto cada jugador y las escobas;
            }
            Liberar memoria compartida;
            return 0;
        }
        Cierre y eliminacion de memoria compartida y colas
    FIN
\end{lstlisting}

\subsection{Compilación y ejecución del programa}

Con el código completo, para compilar el programa a un archivo binario ejecutable se llama al comando \texttt{gcc} (\textit{GNU C Compiler}):

\begin{center}
    \texttt{\$ gcc servidorEscoba.c -o servidorEscoba}\\
\end{center}

Con lo que se obtienen el archivo binario ejecutable, el cual, esta situado en la carpeta en la que se encuentra, se ejecutan desde la terminal de la siguiente manera:

\begin{center}
    \texttt{\$ ./servidorEscoba}\\
\end{center}

Luego, se deben ejecutar los clientes de telnet

\begin{center}
    \texttt{\$ netcat localhost 1234}\\
\end{center}

Es importante ejecutar primero el servidor y luego los clientes.