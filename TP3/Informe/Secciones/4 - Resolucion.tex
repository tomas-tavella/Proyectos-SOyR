\section{Resolución}

Se utilizaron las siguientes bibliotecas de C para poder llevar a cabo la resolución del problema planteado:
\begin{itemize}
    \item Para ambas implementaciones:
    \begin{itemize}
        \item \texttt{<sys/ipc.h>}: biblioteca de \textit{System V} para la comunicación entre procesos.
        \item \texttt{<sys/time.h>}: biblioteca para obtener el tiempo de la \textit{timestamp}.
        \item \texttt{<sys/shm.h>}: biblioteca de \textit{System V} para la memoria compartida.
    \end{itemize}
    \item Para la resolución con semáforos:
    \begin{itemize}
        \item \texttt{<sys/sem.h>}: implementación de \textit{System V} para semáforos.
    \end{itemize}
    \item Para la resolución por colas de mensajes:
    \begin{itemize}
        \item \texttt{<sys/msg.h>}: implementación de \textit{System V} para colas de mensajes.\\
    \end{itemize}
\end{itemize}

En ambos casos se eligió reservar dos segmentos de memoria compartida, uno para cada mitad del \textit{buffer}, con capacidad para almacenar 100 estructuras de datos en total. Esto se logró mediante la función \texttt{shmget()} (contenida en la biblioteca \texttt{<sys/shm.h>}), a la cual se le pasan como argumentos el tamaño del segmento y una clave única (obtenida con la función \texttt{ftok()}) que debe ser la misma para el productor y el consumidor, para así poder compartir los segmentos creados.\\

\subsection{Realización con semáforos}

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\

\subsubsection{Pseudocódigo}

\begin{lstlisting}[language=C]          % No usar tildes en el pseudocódigo
    Productor:
    INICIO
        Declaracion y asignacion de variables, macros y estructuras;
        Se obtiene la clave de las dos memorias compartidas y el semaforo (en el caso de que no las obtenga imprime error);
        Se llama al sistema para obtener el ID de las memorias compartidas (en el caso de que no las obtenga imprime error);
        Se asocia el espacio de memoria compartida con un puntero(si no puede asociar imprime error);
        Creacion de semaforos (si no los puede crear imprime error);
        Inicializacion de semaforos;
        Verificacion de la existencia del archivo datos.dat;
        Se obtiene el tiempo de UNIX inicial;
        Inicializo variables auxiliares para los buffers;
        Mientras(1){
        
        }
    
    
\end{lstlisting}

\subsection{Realización con colas de mensajes}

La implementación por cola de mensajes emplea dos colas con dos tipos de mensajes. Se utiliza una \textit{queue} por buffer, y los tipos de mensaje indican si el buffer está listo para ser escrito, o para ser leído. El productor siempre envía mensajes de un tipo, y el consumidor envía mensajes del otro.

\subsubsection{Pseudocódigo}

\begin{lstlisting}[language=C]          % No usar tildes en el pseudocódigo
    Productor:
    INICIO
        Declarar y asignar variables, macros y estructuras;
        Obtener la clave de las dos memorias compartidas y colas de mensaje (en el caso de que no las obtenga imprime error);
        Llamar al sistema para obtener el ID de las memorias compartidas (en el caso de que no las obtenga imprime error);
        Asociar el espacio de memoria compartida con un puntero(si no puede asociar imprime error);
        Crear colas de mensajes (si no los puede crear imprime error);
        Verificar de la existencia del archivo datos.dat;
        Obtener el tiempo de UNIX inicial;
        Inicializar variables auxiliares para los buffers;
        Mientras(no es el fin del archivo){
            Esperar mensaje que se puede escribir el buffer 1;
            Llenar buffer con datos;
            Preparar mensaje de "listo para leer";
            Enviar mensaje en cola 1;

            Esperar mensaje que se puede escribir el buffer 2;
            Llenar buffer con datos;
            Preparar mensaje de "listo para leer";
            Enviar mensaje en cola 2;
        }
        Cerrar archivo;
        Liberar memoria compartida;
    FIN

    Consumidor:
    INICIO
        Declarar y asignar variables, macros y estructuras;
        Obtener la clave de las dos memorias compartidas y colas de mensaje (en el caso de que no las obtenga imprime error);
        Llamar al sistema para obtener el ID de las memorias compartidas (en el caso de que no las obtenga imprime error);
        Asociar el espacio de memoria compartida con un puntero(si no puede asociar imprime error);
        Crear colas de mensajes (si no los puede crear imprime error);
        Enviar mensaje de "ambos buffers listos para escribir";
        Abrir archivo de destino en modo escritura;
        Mientras(1){
            Esperar mensaje que se puede leer el buffer 1;
            Si el mensaje indicaba fin del archivo, salir;
            Leer buffer, imprimir en pantalla y en archivo de destino;
            Preparar mensaje de "listo para escribir";
            Enviar mensaje en cola 1;

            Esperar mensaje que se puede leer el buffer 2;
            Si el mensaje indicaba fin del archivo, salir;
            Leer buffer, imprimir en pantalla y en archivo de destino;
            Preparar mensaje de "listo para escribir";
            Enviar mensaje en cola 2;
        }
        Cerrar archivo;
        Liberar memoria compartida;
        Liberar colas de mensajes;
    FIN
    
\end{lstlisting}

\subsection{Compilación y ejecución de los programas}

Con el código completo, para compilar los programas a un archivo binario ejecutable se llama al comando \texttt{gcc} (\textit{GNU C Compiler}):

\begin{center}
    \texttt{\$ gcc productor\_sem.c -o prod\_sem}\\
    \texttt{\$ gcc consumidor\_sem.c -o cons\_sem}\\
    \texttt{\$ gcc productor\_col.c -o prod\_col}\\
    \texttt{\$ gcc consumidor\_col.c -o cons\_col}\\
\end{center}

Con lo que se obtienen cuatro archivos binarios ejecutables, los cuales, estando situados en la carpeta en la que se encuentran, se ejecutan desde la terminal de la siguiente manera:

\begin{center}
    \texttt{\$ ./prod\_sem}\\
    \texttt{\$ ./cons\_sem}\\
    \texttt{\$ ./prod\_col}\\
    \texttt{\$ ./cons\_col}\\
\end{center}

Es importante ejecutar los productores antes que los consumidores, para cualquiera de las dos implementaciones, por la forma en que se maneja la sincronización.