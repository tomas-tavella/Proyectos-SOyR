\section{Resolución}

Se utilizaron las siguientes bibliotecas de C para poder llevar a cabo la resolución del problema planteado:
\begin{itemize}
    \item Para ambas implementaciones:
    \begin{itemize}
        \item \texttt{<sys/ipc.h>}: biblioteca de \textit{System V} para la comunicación entre procesos.
        \item \texttt{<sys/time.h>}: biblioteca para obtener el tiempo de la \textit{timestamp}.
        \item \texttt{<sys/shm.h>}: biblioteca de \textit{System V} para la memoria compartida.
    \end{itemize}
    \item Para la resolución con semáforos:
    \begin{itemize}
        \item \texttt{<sys/sem.h>}: implementación de \textit{System V} para semáforos.
    \end{itemize}
    \item Para la resolución por colas de mensajes:
    \begin{itemize}
        \item \texttt{<sys/msg.h>}: implementación de \textit{System V} para colas de mensajes.\\
    \end{itemize}
\end{itemize}

En ambos casos se eligió reservar dos segmentos de memoria compartida, uno para cada mitad del \textit{buffer}, con capacidad para almacenar 100 estructuras de datos en total. Esto se logró mediante la función \texttt{shmget()} (contenida en la biblioteca \texttt{<sys/shm.h>}), a la cual se le pasan como argumentos el tamaño del segmento y una clave única (obtenida con la función \texttt{ftok()}) que debe ser la misma para el productor y el consumidor, para así poder compartir los segmentos creados.\\

\subsection{Realización con semáforos}

Para la implementación con semáforos, se utilizaron las funciones \texttt{semget()}, \texttt{semctl()}, \texttt{semop()} incluidas en la biblioteca apropiada para implementar 3 semáforos distintos:

\begin{itemize}
    \item \textbf{Semáforo del \textit{buffer} 1}: Este semáforo es bloqueado por alguno de los dos procesos al comenzar operaciones sobre el primer \textit{buffer}, y desbloqueado al terminarlas.
    \item \textbf{Semáforo del \textit{buffer} 2}: De manera similar al semaforo anterior, es bloqueado por alguno de los dos procesos al comenzar operaciones sobre el segundo buffer, y desbloqueado al terminarlas.
    \item \textbf{Semáforo de sincronización}: Se encarga de sincronizar los dos programas, de manera que el productor no sobrescriba datos aún no consumidos.
\end{itemize}

Primeramente, se crean los semáforos y espacios de memoria compartida (con \texttt{shmget()} y \texttt{semget()}), utilizando claves únicas obtenidas con la función \texttt{ftok()}. En este caso, tanto la memoria compartida como los semáforos se crean en el programa productor, por lo que si se llama al consumidor previo a este, se va a arrojar en pantalla un error indicando que no se pudieron obtener los recursos.\\

Una vez creados los semáforos, se inicializan dentro del productor mediante \texttt{semctl()}, y una vez que comienza la lectura y escritura de datos, se opera sobre los mismos mediante la función \texttt{semop} (para incrementar la legibilidad del código, las tres instrucciones requeridas para operar un semáforo se sintetizaron en un macro definido en el \textit{header} del programa).\\

Finalmente, al terminar de correr el productor, se llaman a \texttt{shmctl()} y \texttt{semctl()}, para indicar al sistema que destruya los semáforos y las memorias compartidas que se crearon una vez que el ultimo programa haya dejado de utilizarlos (en este caso el consumidor).\\

\subsubsection{Pseudocódigo}

\begin{lstlisting}[language=C]          % No usar tildes en el pseudocódigo
    Productor:
    INICIO
        Declaracion y asignacion de variables, macros y estructuras;
        Se obtiene la clave de las dos memorias compartidas y el semaforo (en el caso de que no las obtenga imprime error);
        Se llama al sistema para obtener el ID de las memorias compartidas (en el caso de que no las obtenga imprime error);
        Se asocia el espacio de memoria compartida con un puntero(si no puede asociar imprime error);
        Creacion de semaforos (si no los puede crear imprime error);
        Inicializacion de semaforos;
        Verificacion de la existencia del archivo datos.dat;
        Se obtiene el tiempo de UNIX inicial;
        Inicializo variables auxiliares para los buffers;
        Mientras(1){
	        Se bloquea el semaforo del Buffer1;
	        Se lee una linea del archivo .dat;
	        Mientras(No se llegue al fin del buffer1){
		        Se copian los datos en el buffer1;
		        Se lee una linea del archivo .dat;
		        Si(Se llego al final del archivo){
			        Se sale del bucle;
                }
                Sino{
    	            Sigue en el bucle;
                }
                Se incrementan la variable para recorrer el buffer y la del id;
	        }
	        Si(Se llego al final del archivo){
	            Se sale del bucle;
            }
            Se resetea la variable que recorre el buffer;
            Se desbloquea el semaforo del Buffer1;
            Se bloquea el semaforo del Buffer2;
            Se bloquea el semaforo de sincronizacion;
            Se lee una linea del archivo.dat;
            Mientras(No se llegue al fin del buffer2){
		        Se copian los datos en el buffer2;
		        Se lee una linea del archivo .dat;
		        Si(Se llego al final del archivo){
			        Se sale del bucle;
                }
                Sino{
                    Sigue en el bucle;
                }
                Se incrementan la variable para recorrer el buffer y la del ID;
            }
            Si(Se llego al final del archivo){
        	    Se sale del bucle;
            }
            Se resetea la variable que recorre el buffer;
            Se desbloquea el semaforo del Buffer2;
            Se bloquea el semaforo de sincronizacion;
        }
        Se pone un ID Null despues de llegar al ultimo elemento para avisarle al consumidor que se llego al EOF;
        Se cierra el archivo .dat;
        Se libera la memoria compartida y se remueven los semaforos;
    FIN

    Consumidor:
    INICIO
        Declaracion y asignacion de variables, macros y estructuras;
        Se obtiene la clave de las dos memorias compartidas y el semaforo (en el caso de que no las obtenga imprime error);
        Se llama al sistema para obtener el ID de las memorias compartidas (en el caso de que no las obtenga imprime error);
        Se asocia el espacio de memoria compartida con un puntero(si no puede asociar imprime error);
        Creacion de semaforos (si no los puede crear imprime error);
        Inicializacion de semaforos;
        Verificacion de la existencia del archivo datos.dat;
        Inicializo variables auxiliares para los buffers;
        Mientras(1){
	        Se bloquea el semaforo del Buffer1;
	        Mientras(No se llegue al fin del buffer1 y el ID del mismo no sea -1){
		        Se copian los datos del buffer1 en el archivo csv y se imprimen en pantalla;
		        Se incrementan la variable para recorrer el buffer;
		        Si(Se encontro el ID -1){
			        Se sale del bucle;
                }
	        }
	        Se resetea la variable que recorre el buffer;
	        Si(Se encontro el ID -1){
	            Se sale del bucle principal;
            }
            Se desbloquea el semaforo del Buffer1;
            Se desbloquea el semaforo de sincronizacion;
            Se bloquea el semaforo del Buffer2;
		    Mientras(No se llegue al fin del buffer2 y el ID del mismo no sea -1){
		        Se copian los datos del buffer2 en el archivo csv y se imprimen en pantalla;
		        Se incrementan la variable para recorrer el buffer;
		        Si(Se encontro el ID -1){
			        Se sale del bucle;
                }
	        }
	        Se resetea la variable que recorre el buffer;
	        Si(Se encontro el ID -1){
	            Se sale del bucle principal;
            }
            Se desbloquea el semaforo del Buffer2;
            Se desbloquea el semaforo de sincronizacion;
            Si(Se encontro el ID -1){
	            Se sale del bucle principal;
            }
        }
        Se cierra el archivo .csv;
        Se libera la memoria compartida y se remueven los semaforos;
    FIN

    
    
\end{lstlisting}

\subsection{Realización con colas de mensajes}

La implementación por cola de mensajes emplea dos colas con dos tipos de mensajes. Se utiliza una \textit{queue} por buffer, y los tipos de mensaje indican si el buffer está listo para ser escrito, o para ser leído. El productor siempre envía mensajes de un tipo, y el consumidor envía mensajes del otro. Para la sincronización, el ambos programas esperan primero a recibir el mensaje del tipo que corresponda antes de operar con la memoria compartida, y una vez que terminan envían el mensaje recíproco. Al iniciar, el consumidor es el primero en enviar mensajes de que los buffers están disponibles, con lo cual ningún programa empieza por separado, sino que el trabajo sobre la memoria compartida se realiza solo con los dos programas en ejecución.\\

\subsubsection{Pseudocódigo}

\begin{lstlisting}[language=C]          % No usar tildes en el pseudocódigo
    Productor:
    INICIO
        Declarar y asignar variables, macros y estructuras;
        Obtener la clave de las dos memorias compartidas y colas de mensaje (en el caso de que no las obtenga imprime error);
        Llamar al sistema para obtener el ID de las memorias compartidas (en el caso de que no las obtenga imprime error);
        Asociar el espacio de memoria compartida con un puntero(si no puede asociar imprime error);
        Crear colas de mensajes (si no los puede crear imprime error);
        Verificar de la existencia del archivo datos.dat;
        Obtener el tiempo de UNIX inicial;
        Inicializar variables auxiliares para los buffers;
        Mientras(no es el fin del archivo){
            Esperar mensaje que se puede escribir el buffer 1;
            Llenar buffer con datos;
            Preparar mensaje de "listo para leer";
            Enviar mensaje en cola 1;

            Esperar mensaje que se puede escribir el buffer 2;
            Llenar buffer con datos;
            Preparar mensaje de "listo para leer";
            Enviar mensaje en cola 2;
        }
        Cerrar archivo;
        Liberar memoria compartida;
    FIN

    Consumidor:
    INICIO
        Declarar y asignar variables, macros y estructuras;
        Obtener la clave de las dos memorias compartidas y colas de mensaje (en el caso de que no las obtenga imprime error);
        Llamar al sistema para obtener el ID de las memorias compartidas (en el caso de que no las obtenga imprime error);
        Asociar el espacio de memoria compartida con un puntero(si no puede asociar imprime error);
        Crear colas de mensajes (si no los puede crear imprime error);
        Enviar mensaje de "ambos buffers listos para escribir";
        Abrir archivo de destino en modo escritura;
        Mientras(1){
            Esperar mensaje que se puede leer el buffer 1;
            Si el mensaje indicaba fin del archivo, salir;
            Leer buffer, imprimir en pantalla y en archivo de destino;
            Preparar mensaje de "listo para escribir";
            Enviar mensaje en cola 1;

            Esperar mensaje que se puede leer el buffer 2;
            Si el mensaje indicaba fin del archivo, salir;
            Leer buffer, imprimir en pantalla y en archivo de destino;
            Preparar mensaje de "listo para escribir";
            Enviar mensaje en cola 2;
        }
        Cerrar archivo;
        Liberar memoria compartida;
        Liberar colas de mensajes;
    FIN
    
\end{lstlisting}

\subsection{Compilación y ejecución de los programas}

Con el código completo, para compilar los programas a un archivo binario ejecutable se llama al comando \texttt{gcc} (\textit{GNU C Compiler}):

\begin{center}
    \texttt{\$ gcc productor\_sem.c -o prod\_sem}\\
    \texttt{\$ gcc consumidor\_sem.c -o cons\_sem}\\
    \texttt{\$ gcc productor\_col.c -o prod\_col}\\
    \texttt{\$ gcc consumidor\_col.c -o cons\_col}\\
\end{center}

Con lo que se obtienen cuatro archivos binarios ejecutables, los cuales, estando situados en la carpeta en la que se encuentran, se ejecutan desde la terminal de la siguiente manera:

\begin{center}
    \texttt{\$ ./prod\_sem}\\
    \texttt{\$ ./cons\_sem}\\
    \texttt{\$ ./prod\_col}\\
    \texttt{\$ ./cons\_col}\\
\end{center}

Es importante ejecutar los productores antes que los consumidores, para cualquiera de las dos implementaciones, por la forma en que se maneja la sincronización.